<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
  <script>
    function assertEqual(arg1, arg2) {
      if (!(arg1===arg2)) {
        throw new Error('Expected ' + arg1 + ' to equal ' + arg2);
      }
    }

    function Class(TypeDef) {
      TypeDef.reflectAnnotations = this.annotations;
      return TypeDef;
    }


    function MyComponent() {
    }

    //3 ways of calling a function:
    //new View()
    //View()
    //@View

    var ViewMetadata = function(viewObj) {
      this.template = viewObj.template;
      this.templateUrl = viewObj.templateUrl;
      this.directives = viewObj.directives;
    };

    function makeDecorator(MetaDataType, chainFn, metadataFactoryFn) {

      function DecoratorFactory(viewData) {
        var metaDataInstance = metadataFactoryFn ? metadataFactoryFn(viewData) : new MetaDataType(viewData);

        if (this instanceof MetaDataType) { //called as new View (syntax used to avoid annotations)

          return metaDataInstance;

        } else {

          var TypeDecorator = function TypeDecorator(TypeToES7Decorate) {
            if (!TypeToES7Decorate.reflectAnnotations) {
              TypeToES7Decorate.reflectAnnotations = [];
            }
            TypeToES7Decorate.reflectAnnotations.push(metaDataInstance);
            return TypeToES7Decorate;
          };

          var newAnnotations = [];
          if (typeof this === "function" && this.annotations) { //called like View({}).View({})
            newAnnotations = this.annotations;
          }
          newAnnotations.push(metaDataInstance);

          TypeDecorator.annotations = newAnnotations;
          TypeDecorator.Class = Class;
          if (chainFn) {
            chainFn(TypeDecorator);
          }

          return TypeDecorator;
        }
      }

      DecoratorFactory.prototype = Object.create(MetaDataType.prototype); //this is to make the "if (this instanceof MetaDataType)" check work
      //which in turn allows us to detect if a given function was run as a constructor (with new) or not
      //maybe there is another way of doing the same?

      return DecoratorFactory; //needs to return a constructor function
    }

    var View = makeDecorator(ViewMetadata, function(TypeDecorator) {
      TypeDecorator.View = View;
    });


    //new View({})
    assertEqual(new View({template: 'foo'}).template, 'foo');

    //View
    View({template: 'foo'}).Class(MyComponent);
    assertEqual(MyComponent.reflectAnnotations[0].template, 'foo');
    MyComponent.reflectAnnotations = null;

    //View with chaining
    View({template: 'foo'}).View({template: 'bar'}).Class(MyComponent);
    assertEqual(MyComponent.reflectAnnotations[0].template, 'foo');
    assertEqual(MyComponent.reflectAnnotations[1].template, 'bar');
    MyComponent.reflectAnnotations = null;

    //@View
    View({template: 'foo'})(MyComponent);
    assertEqual(MyComponent.reflectAnnotations[0].template, 'foo');
    MyComponent.reflectAnnotations = null;

    //@View with chaining
    View({template: 'foo'})(MyComponent);
    View({template: 'bar'})(MyComponent);
    assertEqual(MyComponent.reflectAnnotations[0].template, 'foo');
    assertEqual(MyComponent.reflectAnnotations[1].template, 'bar');
    MyComponent.reflectAnnotations = null;

    //@SuperView
    var SuperView = makeDecorator(ViewMetadata, function(TypeDecorator) {
      TypeDecorator.View = View;
      TypeDecorator.SuperView = SuperView;
    }, function(viewData) {

      return new ViewMetadata({
        template: viewData.template,
        templateUrl: viewData.templateUrl,
        directives: [-1, viewData.directives]
      });
    });

    SuperView({template: 'foo', directives: [0, 1]})(MyComponent);
    assertEqual(MyComponent.reflectAnnotations[0].template, 'foo');
    assertEqual(MyComponent.reflectAnnotations[0].directives[0], -1);
    assertEqual(MyComponent.reflectAnnotations[0].directives[1][0], 0);
    MyComponent.reflectAnnotations = null;

    console.log('ALL GOOD!');
  </script>
</head>
<body>

</body>
</html>
